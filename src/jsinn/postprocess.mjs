#!/usr/bin/env node
// jsinn post-processing: cleans up nim js output after macro rewriting

import { readFileSync, writeFileSync } from "fs";

// Dead runtime variables that nim js always emits but are never used
// when jsinn macros eliminate stdlib dependencies.
const DEAD_HEADER_VARS = new Set([
  "framePtr",
  "excHandler",
  "lastJSError",
]);

/**
 * Strip the dead Nim runtime header:
 * - /* Generated by the Nim Compiler vX.Y.Z *​/
 * - var framePtr = null;
 * - var excHandler = 0;
 * - var lastJSError = null;
 * - var objectID_NNNN = [0];
 */
export function stripHeader(source) {
  const lines = source.split("\n");
  const kept = [];
  let leadingBlank = true;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip the Nim compiler comment
    if (trimmed.startsWith("/* Generated by the Nim Compiler")) continue;

    // Skip known dead runtime vars
    const varMatch = trimmed.match(/^var\s+(\w+)\s*=/);
    if (varMatch) {
      const name = varMatch[1];
      if (DEAD_HEADER_VARS.has(name) || name.startsWith("objectID_")) continue;
    }

    // Skip leading blank lines after stripping
    if (leadingBlank && trimmed === "") continue;
    leadingBlank = false;

    kept.push(line);
  }

  return kept.join("\n");
}

/**
 * Demangle Nim-generated identifier names.
 *
 * Patterns:
 *   Function names:  sanitizeEnvVar__test95tier2_u61  →  sanitizeEnvVar
 *   Variable names:  result_553648191                 →  result
 *   Parameter names: request_p0                       →  request
 */
export function demangleNames(source) {
  // Collect all identifiers and build rename map (longest first to avoid partial matches)
  const renameMap = new Map();

  // Pattern 1: Function names — name__module_uNN (double underscore + module info)
  for (const m of source.matchAll(/\b([a-zA-Z_]\w*?)__\w+_u\d+\b/g)) {
    renameMap.set(m[0], m[1]);
  }

  // Pattern 2: Variable names — name_NNNNNN (6+ digit Nim symbol ID)
  for (const m of source.matchAll(/\b([a-zA-Z_]\w*?)_(\d{6,})\b/g)) {
    renameMap.set(m[0], m[1]);
  }

  // Pattern 3: Parameter names — name_pN (parameter index suffix)
  for (const m of source.matchAll(/\b([a-zA-Z_]\w*?)_p(\d)\b/g)) {
    renameMap.set(m[0], m[1]);
  }

  // Sort by length descending to avoid partial replacement
  const sorted = [...renameMap.entries()].sort((a, b) => b[0].length - a[0].length);

  let result = source;
  for (const [mangled, base] of sorted) {
    result = result.replaceAll(mangled, base);
  }

  return result;
}

/**
 * Eliminate the BeforeRet labeled block pattern.
 *
 * Nim's JS backend uses this pattern for functions with multiple return points:
 *   var result = null;
 *   BeforeRet: {
 *     result = EXPR;
 *     break BeforeRet;
 *   };
 *   return result;
 *
 * This rewrites to direct return statements.
 * Also handles simple result-assignment functions (no BeforeRet).
 */
export function eliminateBeforeRet(source) {
  let s = source;

  // Step 1: Replace "result = EXPR;\n...break BeforeRet;" with "return EXPR;"
  s = s.replace(/^(\s*)result\s*=\s*(.+?);\s*\n\s*break BeforeRet;/gm,
    (_, indent, expr) => `${indent}return ${expr};`);

  // Step 2: Remove "BeforeRet: {" lines
  s = s.replace(/^(\s*)BeforeRet:\s*\{/gm, "");

  // Step 3: Remove closing "};" for BeforeRet (at same indent as function body)
  // This is the bare "};" that was the end of the BeforeRet block
  s = s.replace(/^\s*\};\s*$/gm, (match) => {
    // Only remove if it looks like a BeforeRet closer (standalone };)
    return "";
  });

  // Step 4: Remove "var result = null;" declarations
  s = s.replace(/^\s*var result\s*=\s*null;\s*$/gm, "");

  // Step 5: Remove orphaned "return result;" (the one after BeforeRet block)
  s = s.replace(/^\s*return result;\s*$/gm, "");

  // Step 6: Handle simple result pattern (no BeforeRet, just result = EXPR; ... return result;)
  // After steps above, any remaining "result = EXPR;" followed later by a function end
  // indicates a simple single-assignment function.
  s = s.replace(/^(\s*)result\s*=\s*(.+?);$/gm, (_, indent, expr) => `${indent}return ${expr};`);

  // Step 7: Collapse multiple blank lines to at most one
  s = s.replace(/\n{3,}/g, "\n\n");

  // Step 8: Remove trailing blank lines inside functions (before closing })
  s = s.replace(/\n\n(\s*\})/g, "\n$1");

  return s;
}

// CLI: node postprocess.mjs <input> [output]
const args = process.argv.slice(2);
if (args.length >= 1) {
  let output = readFileSync(args[0], "utf-8");
  output = stripHeader(output);
  output = demangleNames(output);
  output = eliminateBeforeRet(output);
  if (args[1]) {
    writeFileSync(args[1], output);
  } else {
    process.stdout.write(output);
  }
}
